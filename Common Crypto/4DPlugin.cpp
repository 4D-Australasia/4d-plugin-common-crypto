/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Common Crypto
 #	author : miyako
 #	2015/06/22
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

#ifndef _CC_COMMON_HMAC_H_
void CC_EVP(const EVP_MD *evp, uint32_t mlen, const void *data, uint32_t len, unsigned char *md)
{
	unsigned int mdlen = mlen;
	EVP_MD_CTX* c = EVP_MD_CTX_create();
	EVP_MD_CTX_init(c);
	EVP_DigestInit(c, evp);
	EVP_DigestUpdate(c, data, len);
	EVP_DigestFinal(c, md, &mdlen);	
	EVP_MD_CTX_destroy(c);			
}

void CC_MD5(const void *data, uint32_t len, unsigned char *md)
{
	CC_EVP(EVP_md5(), 16, data, len, md);		
}

void CC_SHA1(const void *data, uint32_t len, unsigned char *md)
{
	CC_EVP(EVP_sha1(), 20, data, len, md);		
}


void CC_SHA256(const void *data, uint32_t len, unsigned char *md)
{
	CC_EVP(EVP_sha256(), 32, data, len, md);
}

void CC_SHA384(const void *data, uint32_t len, unsigned char *md)
{
	CC_EVP(EVP_sha384(), 48, data, len, md);		
}

void CC_SHA512(const void *data, uint32_t len, unsigned char *md)
{
	CC_EVP(EVP_sha512(), 64, data, len, md);			
}

#endif

#pragma mark -

bool IsProcessOnExit(){    
    C_TEXT name;
    PA_long32 state, time;
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
    CUTF16String procName(name.getUTF16StringPtr());
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

void OnStartup(){
    OpenSSL_add_all_algorithms();//for PEM_From_P12
}

void OnCloseProcess(){
    if(IsProcessOnExit()){
        EVP_cleanup();    
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
        case kInitPlugin :
        case kServerInitPlugin :            
            OnStartup();
            break;    

        case kCloseProcess :            
            OnCloseProcess();
            break;
                        
// --- Common Crypto

		case 1 :
			PEM_From_P12(pResult, pParams);
			break;

		case 2 :
			Get_timestamp(pResult, pParams);
			break;

		case 3 :
			Get_timestring(pResult, pParams);
			break;

		case 4 :
			Get_unixtime(pResult, pParams);
			break;

		case 5 :
			RSASHA256(pResult, pParams);
			break;

		case 6 :
			HMACMD5(pResult, pParams);
			break;

		case 7 :
			HMACSHA1(pResult, pParams);
			break;

		case 8 :
			HMACSHA256(pResult, pParams);
			break;

		case 9 :
			HMACSHA384(pResult, pParams);
			break;

		case 10 :
			HMACSHA512(pResult, pParams);
			break;

		case 11 :
			SHA384(pResult, pParams);
			break;

		case 12 :
			SHA512(pResult, pParams);
			break;

		case 13 :
			MD5(pResult, pParams);
			break;

		case 14 :
			SHA1(pResult, pParams);
			break;

		case 15 :
			SHA256(pResult, pParams);
			break;

		case 16 :
			RSASHA1(pResult, pParams);
			break;

		case 17 :
			AES128(pResult, pParams);
			break;

		case 18 :
			AES192(pResult, pParams);
			break;

		case 19 :
			AES256(pResult, pParams);
			break;
	}
}

// --------------------------------- Common Crypto --------------------------------

#pragma mark -

void AES128(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);

	EVP_CIPHER_CTX ctx;
	EVP_CIPHER_CTX_init(&ctx);

	unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];
	
	const EVP_CIPHER *cipher;
	
	switch (Param4.getIntValue())
	{
		case 0:
			cipher = EVP_aes_128_ecb();
		break;
		case 1:
			cipher = EVP_aes_128_cbc();
		break;
		case 2:
			cipher = EVP_aes_128_cfb1();
		break;
		case 3:
			cipher = EVP_aes_128_cfb8();
		break;
		case 4:
			cipher = EVP_aes_128_cfb128();
		break;
		case 5:
			cipher = EVP_aes_128_ofb();
		break;
		case 6:
			cipher = EVP_aes_128_ctr();
		break;
		case 7:
			cipher = EVP_aes_128_gcm();
		break;
		case 8:
			cipher = EVP_aes_128_ccm();
		break;
		case 9:
			cipher = EVP_aes_128_xts();
		break;
		default:
			cipher = EVP_aes_128_ecb();
		break;
	}

	const unsigned char *source = (const unsigned char *)Param1.getBytesPtr();
	int source_len = Param1.getBytesLength();
	int crypted_len, tail_len;
	
	// passphrase -> key, iv
  if (EVP_BytesToKey(cipher, EVP_md5(), NULL,
		Param2.getBytesPtr(), Param2.getBytesLength(),
		2048, key, iv) > 0) {
		if(EVP_CipherInit(&ctx, cipher, key, iv, 0 == Param3.getIntValue()))
		{
			size_t buf_size = source_len + EVP_MAX_BLOCK_LENGTH;
			unsigned char *buf = (unsigned char *)calloc(buf_size, sizeof(unsigned char));
			if(EVP_CipherUpdate(&ctx, buf, &crypted_len, source, source_len))
			{
				if(EVP_CipherFinal(&ctx, (buf + crypted_len), &tail_len))
				{
					crypted_len += tail_len;
					C_BLOB temp;
					temp.setBytes((const uint8_t *)buf, crypted_len);
					
					switch (Param5.getIntValue())
					{
						case 1:
							temp.toB64Text(&returnValue);	
							break;
						default:
							temp.toHexText(&returnValue);	
							break;
					}
				}
			}
			free(buf);
		}
		EVP_CIPHER_CTX_cleanup(&ctx);
  }

	returnValue.setReturn(pResult);
}

void AES192(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);

	EVP_CIPHER_CTX ctx;
	EVP_CIPHER_CTX_init(&ctx);

	unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];
	
	const EVP_CIPHER *cipher;
	
	switch (Param4.getIntValue())
	{
		case 0:
			cipher = EVP_aes_192_ecb();
		break;
		case 1:
			cipher = EVP_aes_192_cbc();
		break;
		case 2:
			cipher = EVP_aes_192_cfb1();
		break;
		case 3:
			cipher = EVP_aes_192_cfb8();
		break;
		case 4:
			cipher = EVP_aes_192_cfb128();
		break;
		case 5:
			cipher = EVP_aes_192_ofb();
		break;
		case 6:
			cipher = EVP_aes_192_ctr();
		break;
		case 7:
			cipher = EVP_aes_192_gcm();
		break;
		case 8:
			cipher = EVP_aes_192_ccm();
		break;
		default:
			cipher = EVP_aes_192_ecb();
		break;
	}

	const unsigned char *source = (const unsigned char *)Param1.getBytesPtr();
	int source_len = Param1.getBytesLength();
	int crypted_len, tail_len;
	
	// passphrase -> key, iv
  if (EVP_BytesToKey(cipher, EVP_md5(), NULL,
		Param2.getBytesPtr(), Param2.getBytesLength(),
		2048, key, iv) > 0) {
		if(EVP_CipherInit(&ctx, cipher, key, iv, 0 == Param3.getIntValue()))
		{
			size_t buf_size = source_len + EVP_MAX_BLOCK_LENGTH;
			unsigned char *buf = (unsigned char *)calloc(buf_size, sizeof(unsigned char));
			if(EVP_CipherUpdate(&ctx, buf, &crypted_len, source, source_len))
			{
				if(EVP_CipherFinal(&ctx, (buf + crypted_len), &tail_len))
				{
					crypted_len += tail_len;
					C_BLOB temp;
					temp.setBytes((const uint8_t *)buf, crypted_len);
					
					switch (Param5.getIntValue())
					{
						case 1:
							temp.toB64Text(&returnValue);	
							break;
						default:
							temp.toHexText(&returnValue);	
							break;
					}
				}
			}
			free(buf);
		}
		EVP_CIPHER_CTX_cleanup(&ctx);
  }

	returnValue.setReturn(pResult);
}

void AES256(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_LONGINT Param4;
	C_LONGINT Param5;
	C_TEXT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	Param5.fromParamAtIndex(pParams, 5);

	EVP_CIPHER_CTX ctx;
	EVP_CIPHER_CTX_init(&ctx);

	unsigned char key[EVP_MAX_KEY_LENGTH], iv[EVP_MAX_IV_LENGTH];
	
	const EVP_CIPHER *cipher;
	
	switch (Param4.getIntValue())
	{
		case 0:
			cipher = EVP_aes_256_ecb();
		break;
		case 1:
			cipher = EVP_aes_256_cbc();
		break;
		case 2:
			cipher = EVP_aes_256_cfb1();
		break;
		case 3:
			cipher = EVP_aes_256_cfb8();
		break;
		case 4:
			cipher = EVP_aes_256_cfb128();
		break;
		case 5:
			cipher = EVP_aes_256_ofb();
		break;
		case 6:
			cipher = EVP_aes_256_ctr();
		break;
		case 7:
			cipher = EVP_aes_256_gcm();
		break;
		case 8:
			cipher = EVP_aes_256_ccm();
		break;
		case 9:
			cipher = EVP_aes_256_xts();
		break;
		default:
			cipher = EVP_aes_256_ecb();
		break;
	}

	const unsigned char *source = (const unsigned char *)Param1.getBytesPtr();
	int source_len = Param1.getBytesLength();
	int crypted_len, tail_len;
	
	// passphrase -> key, iv
  if (EVP_BytesToKey(cipher, EVP_md5(), NULL,
		Param2.getBytesPtr(), Param2.getBytesLength(),
		2048, key, iv) > 0) {
		if(EVP_CipherInit(&ctx, cipher, key, iv, 0 == Param3.getIntValue()))
		{
			size_t buf_size = source_len + EVP_MAX_BLOCK_LENGTH;
			unsigned char *buf = (unsigned char *)calloc(buf_size, sizeof(unsigned char));
			if(EVP_CipherUpdate(&ctx, buf, &crypted_len, source, source_len))
			{
				if(EVP_CipherFinal(&ctx, (buf + crypted_len), &tail_len))
				{
					crypted_len += tail_len;
					C_BLOB temp;
					temp.setBytes((const uint8_t *)buf, crypted_len);
					
					switch (Param5.getIntValue())
					{
						case 1:
							temp.toB64Text(&returnValue);	
							break;
						default:
							temp.toHexText(&returnValue);	
							break;
					}
				}
			}
			free(buf);
		}
		EVP_CIPHER_CTX_cleanup(&ctx);
  }

	returnValue.setReturn(pResult);
}

#pragma mark -

void PEM_From_P12(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_TEXT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);	
	
	BIO *bio = BIO_new_mem_buf((void *)Param1.getBytesPtr(), Param1.getBytesLength());

	if(bio){
		
		PKCS12 *p12 = d2i_PKCS12_bio(bio, NULL);
		
		if(p12){
			
			EVP_PKEY *key = NULL;
			X509 *cert = NULL;
			STACK_OF(X509) *ca = NULL;
            
			CUTF8String pass;
			Param3.copyUTF8String(&pass);
			
			if(PKCS12_parse(p12, (const char *)pass.c_str(), &key, &cert, &ca)){
				
				BIO *pem = BIO_new(BIO_s_mem());
				
				if(pem){
					
					PEM_write_bio_PrivateKey(pem, key, NULL, NULL, NULL, NULL, (void *)pass.c_str());
					
					char *buf = NULL;
					
					int len = BIO_get_mem_data(pem, &buf);
					
					if(len){
						Param2.setBytes((const uint8_t *)buf, len);
						Param2.toParamAtIndex(pParams, 2);
						CUTF8String pemStr = CUTF8String((const uint8_t *)buf, len);
						returnValue.setUTF8String(&pemStr);
					}
					
					BIO_free(pem);
					
				}
			}
		}
		
		BIO_free(bio);
		
	}	
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

#pragma mark -

void Get_timestamp(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	time_t timestamp = time(NULL);
	char ts[256];	
	
#if VERSIONMAC	
	setenv("TZ",(const char *)"GMT", 1);
#else	
	_wputenv_s(L"TZ",L"GMT"); 
#endif
	
	strftime(ts, 256, "%Y-%m-%dT%XZ",  localtime(&timestamp));
	
	returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
	returnValue.setReturn(pResult);
}

void Get_timestring(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	time_t timestamp = time(NULL);
	char ts[256];	
	
#if VERSIONMAC	
	setenv("TZ",(const char *)"GMT", 1);
#else	
	_wputenv_s(L"TZ",L"GMT"); 
#endif
	
	strftime(ts, 256, "%a, %d %b %y %X %Z",  localtime(&timestamp)); 
	
	returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
	returnValue.setReturn(pResult);
}

void Get_unixtime(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT returnValue;
	
	time_t timestamp = time(NULL);
	char ts[256];
	sprintf((char *)ts, "%i", (int)timestamp);
	
	returnValue.setUTF8String((const uint8_t*)ts, (uint32_t)strlen(ts));
	returnValue.setReturn(pResult);
}

#pragma mark -

void HMACMD5(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(16, sizeof(uint8_t)); 
	uint32_t mdlen = 16;
	
	HMAC(EVP_md5(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &mdlen);		
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 16);
	
	switch (Param3.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	
	returnValue.setReturn(pResult);
}

#pragma mark -

void HMACSHA1(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(20, sizeof(uint8_t)); 
	uint32_t mdlen = 20;
	
	HMAC(EVP_sha1(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &mdlen);		
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 20);
	
	switch (Param3.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void HMACSHA256(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(32, sizeof(uint8_t)); 
	uint32_t mdlen = 32;
	
	HMAC(EVP_sha256(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &mdlen);		
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 32);
	
	switch (Param3.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void HMACSHA384(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(48, sizeof(uint8_t)); 
	uint32_t mdlen = 48;
	
	HMAC(EVP_sha384(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &mdlen);		
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 48);
	
	switch (Param3.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void HMACSHA512(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(64, sizeof(uint8_t)); 
	uint32_t mdlen = 64;
	
	HMAC(EVP_sha512(), (const void *)Param1.getBytesPtr(), (int)Param1.getBytesLength(), (const unsigned char *)Param2.getBytesPtr(), (int)Param2.getBytesLength(), buf, &mdlen);		
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 64);
	
	switch (Param3.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

#pragma mark -

void MD5(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	uint8_t *buf = (uint8_t *)calloc(16, sizeof(uint8_t)); 
	
	CC_MD5((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 16);
	
	switch (Param2.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

#pragma mark -

void SHA1(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	uint8_t *buf = (uint8_t *)calloc(20, sizeof(uint8_t)); 
	
	CC_SHA1((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 20);
	
	switch (Param2.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void SHA256(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	uint8_t *buf = (uint8_t *)calloc(32, sizeof(uint8_t)); 
	
	CC_SHA256((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 32);
	
	switch (Param2.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void SHA384(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	uint8_t *buf = (uint8_t *)calloc(48, sizeof(uint8_t)); 
	
	CC_SHA384((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 48);
	
	switch (Param2.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

void SHA512(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_LONGINT Param2;
	C_TEXT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	uint8_t *buf = (uint8_t *)calloc(64, sizeof(uint8_t)); 
	
	CC_SHA512((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	
	
	C_BLOB temp;
	temp.setBytes((const uint8_t *)buf, 64);
	
	switch (Param2.getIntValue()) 
	{
		case 1:
			temp.toB64Text(&returnValue);	
			break;
		default:
			temp.toHexText(&returnValue);	
			break;
	}
	
	free(buf);
	
	returnValue.setReturn(pResult);
}

#pragma mark -

void RSASHA1(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
    
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	uint8_t *buf = (uint8_t *)calloc(20, sizeof(uint8_t)); 
	
	CC_SHA1((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	    
    
    unsigned int signatureLength = 0;
    
	BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
	
	if(bio){
		
		RSA *key = NULL;
		key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);	
		
		if(key){
			
			uint8_t *sgn = (uint8_t *)calloc(RSA_size(key), sizeof(uint8_t)); 
			
			if(RSA_sign(NID_sha1, buf, 20, sgn, &signatureLength, key)){
				
				C_BLOB temp;
				temp.setBytes((const uint8_t *)sgn, signatureLength);
				
				switch (Param3.getIntValue()) 
				{
					case 1:
						temp.toB64Text(&returnValue);	
						break;
					default:
						temp.toHexText(&returnValue);	
						break;
				}
			}
			
			free(sgn);
		}
		
		BIO_free(bio);
	}
    
	free(buf);
	
	returnValue.setReturn(pResult);
}

void RSASHA256(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_BLOB Param1;
	C_BLOB Param2;
	C_LONGINT Param3;
	C_TEXT returnValue;
    
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);

	uint8_t *buf = (uint8_t *)calloc(32, sizeof(uint8_t)); 
	
	CC_SHA256((unsigned char *)Param1.getBytesPtr(), Param1.getBytesLength(), buf);	    
    
    unsigned int signatureLength = 0;
    
	BIO *bio = BIO_new_mem_buf((void *)Param2.getBytesPtr(), Param2.getBytesLength());
	
	if(bio){
		
		RSA *key = NULL;
		key = PEM_read_bio_RSAPrivateKey(bio, NULL, NULL, NULL);	
		
		if(key){
			
			uint8_t *sgn = (uint8_t *)calloc(RSA_size(key), sizeof(uint8_t)); 
			
			if(RSA_sign(NID_sha256, buf, 32, sgn, &signatureLength, key)){
				
				C_BLOB temp;
				temp.setBytes((const uint8_t *)sgn, signatureLength);
				
				switch (Param3.getIntValue()) 
				{
					case 1:
						temp.toB64Text(&returnValue);	
						break;
					default:
						temp.toHexText(&returnValue);	
						break;
				}
			}
			
			free(sgn);
		}
		
		BIO_free(bio);
	}
    
	free(buf);
	
	returnValue.setReturn(pResult);
}
